import React from 'react';

/**
 * çµ±ä¸€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 
 *
 * è¤‡æ•°ç®‡æ‰€ã§é‡è¤‡ã—ã¦ã„ãŸã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ­ã‚¸ãƒƒã‚¯ã‚’çµ±ä¸€ã—ã€
 * ä¸€è²«æ€§ã¨ä¿å®ˆæ€§ã‚’å‘ä¸Šã•ã›ã‚‹ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
 */

/**
 * ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®è¨­å®šã‚ªãƒ—ã‚·ãƒ§ãƒ³
 */
export interface ErrorHandlingOptions {
  /** ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å—ã‘å–ã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
  onError: (message: string, error?: unknown) => void;
  /** ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆçœç•¥å¯ï¼‰ */
  setLoading?: (isLoading: boolean) => void;
  /** æˆåŠŸæ™‚ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆçœç•¥å¯ï¼‰ */
  successMessage?: string;
  /** ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */
  defaultErrorMessage?: string;
  /** ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«ãƒ­ã‚°ã‚’å‡ºåŠ›ã™ã‚‹ã‹ã©ã†ã‹ */
  enableConsoleLog?: boolean;
  /** æ“ä½œåï¼ˆãƒ­ã‚°ç”¨ï¼‰ */
  operationName?: string;
}

/**
 * æ“ä½œçµæœã®å‹
 */
export interface OperationResult<T> {
  /** æ“ä½œãŒæˆåŠŸã—ãŸã‹ã©ã†ã‹ */
  success: boolean;
  /** çµæœãƒ‡ãƒ¼ã‚¿ï¼ˆæˆåŠŸæ™‚ï¼‰ */
  data?: T;
  /** ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆå¤±æ•—æ™‚ï¼‰ */
  message?: string;
  /** å…ƒã®ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆå¤±æ•—æ™‚ï¼‰ */
  originalError?: unknown;
}

/**
 * çµ±ä¸€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚¯ãƒ©ã‚¹
 */
export class ErrorHandler {
  /**
   * éåŒæœŸæ“ä½œã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’çµ±ä¸€çš„ã«å‡¦ç†
   *
   * @template T - æ“ä½œã®æˆ»ã‚Šå€¤ã®å‹
   * @param operation - å®Ÿè¡Œã™ã‚‹éåŒæœŸæ“ä½œ
   * @param options - ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®è¨­å®š
   * @returns æ“ä½œçµæœã¾ãŸã¯ nullï¼ˆå¤±æ•—æ™‚ï¼‰
   *
   * @example
   * ```typescript
   * // åŸºæœ¬çš„ãªä½¿ç”¨ä¾‹
   * const result = await ErrorHandler.handleAsync(
   *   () => circuitStorage.saveCircuit(name, gates, wires),
   *   {
   *     onError: (message) => setError(message),
   *     setLoading: setIsLoading,
   *     defaultErrorMessage: 'å›è·¯ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ',
   *     operationName: 'å›è·¯ä¿å­˜'
   *   }
   * );
   *
   * if (result) {
   *   console.log('ä¿å­˜æˆåŠŸ:', result);
   * }
   * ```
   */
  static async handleAsync<T>(
    operation: () => Promise<T>,
    options: ErrorHandlingOptions
  ): Promise<T | null> {
    const {
      onError,
      setLoading,
      defaultErrorMessage = 'æ“ä½œã«å¤±æ•—ã—ã¾ã—ãŸ',
      enableConsoleLog = true,
      operationName = 'æ“ä½œ',
    } = options;

    // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°é–‹å§‹
    setLoading?.(true);

    try {
      if (enableConsoleLog) {
        console.log(`ğŸ”„ ${operationName}ã‚’é–‹å§‹...`);
      }

      const result = await operation();

      if (enableConsoleLog) {
        console.log(`âœ… ${operationName}ãŒæˆåŠŸã—ã¾ã—ãŸ`);
      }

      return result;
    } catch (error) {
      const errorMessage = this.extractErrorMessage(error, defaultErrorMessage);

      if (enableConsoleLog) {
        console.error(`âŒ ${operationName}ã«å¤±æ•—:`, error);
      }

      onError(errorMessage, error);
      return null;
    } finally {
      // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çµ‚äº†
      setLoading?.(false);
    }
  }

  /**
   * OperationResultå½¢å¼ã®æ“ä½œã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
   *
   * @template T - æ“ä½œã®æˆ»ã‚Šå€¤ã®å‹
   * @param operation - OperationResultã‚’è¿”ã™éåŒæœŸæ“ä½œ
   * @param options - ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®è¨­å®š
   * @returns æ“ä½œçµæœ
   *
   * @example
   * ```typescript
   * const result = await ErrorHandler.handleOperationResult(
   *   () => circuitStorage.loadCircuit(circuitId),
   *   {
   *     onError: (message) => setError(message),
   *     setLoading: setIsLoading,
   *     operationName: 'å›è·¯èª­ã¿è¾¼ã¿'
   *   }
   * );
   *
   * if (result.success) {
   *   console.log('èª­ã¿è¾¼ã¿æˆåŠŸ:', result.data);
   * }
   * ```
   */
  static async handleOperationResult<T>(
    operation: () => Promise<OperationResult<T>>,
    options: ErrorHandlingOptions
  ): Promise<OperationResult<T>> {
    const {
      onError,
      setLoading,
      enableConsoleLog = true,
      operationName = 'æ“ä½œ',
    } = options;

    // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°é–‹å§‹
    setLoading?.(true);

    try {
      if (enableConsoleLog) {
        console.log(`ğŸ”„ ${operationName}ã‚’é–‹å§‹...`);
      }

      const result = await operation();

      if (result.success) {
        if (enableConsoleLog) {
          console.log(`âœ… ${operationName}ãŒæˆåŠŸã—ã¾ã—ãŸ`);
        }
      } else {
        if (enableConsoleLog) {
          console.warn(`âš ï¸ ${operationName}ãŒå¤±æ•—:`, result.message);
        }
        onError(result.message || 'æ“ä½œã«å¤±æ•—ã—ã¾ã—ãŸ');
      }

      return result;
    } catch (error) {
      const errorMessage = this.extractErrorMessage(
        error,
        'æ“ä½œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ'
      );

      if (enableConsoleLog) {
        console.error(`âŒ ${operationName}ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ:`, error);
      }

      onError(errorMessage, error);

      return {
        success: false,
        message: errorMessage,
        originalError: error,
      };
    } finally {
      // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çµ‚äº†
      setLoading?.(false);
    }
  }

  /**
   * è¤‡æ•°ã®éåŒæœŸæ“ä½œã‚’é †æ¬¡å®Ÿè¡Œ
   *
   * @param operations - å®Ÿè¡Œã™ã‚‹æ“ä½œã®é…åˆ—
   * @param options - ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®è¨­å®š
   * @returns å…¨ã¦ã®æ“ä½œãŒæˆåŠŸã—ãŸå ´åˆã¯true
   */
  static async handleSequentialOperations(
    operations: Array<{
      operation: () => Promise<any>;
      name: string;
    }>,
    options: ErrorHandlingOptions
  ): Promise<boolean> {
    const { onError, setLoading, enableConsoleLog = true } = options;

    setLoading?.(true);

    try {
      for (const { operation, name } of operations) {
        if (enableConsoleLog) {
          console.log(`ğŸ”„ ${name}ã‚’å®Ÿè¡Œä¸­...`);
        }

        await operation();

        if (enableConsoleLog) {
          console.log(`âœ… ${name}ãŒå®Œäº†`);
        }
      }

      return true;
    } catch (error) {
      const errorMessage = this.extractErrorMessage(
        error,
        'æ“ä½œã®å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸ'
      );

      if (enableConsoleLog) {
        console.error('âŒ æ“ä½œã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ:', error);
      }

      onError(errorMessage, error);
      return false;
    } finally {
      setLoading?.(false);
    }
  }

  /**
   * ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰é©åˆ‡ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æŠ½å‡º
   *
   * @param error - ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   * @param defaultMessage - ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
   * @returns é©åˆ‡ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
   */
  static extractErrorMessage(
    error: unknown,
    defaultMessage: string = 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ'
  ): string {
    if (!error) {
      return defaultMessage;
    }

    // Error ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å ´åˆ
    if (error instanceof Error) {
      return error.message || defaultMessage;
    }

    // æ–‡å­—åˆ—ã®å ´åˆ
    if (typeof error === 'string') {
      return error || defaultMessage;
    }

    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ message ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒã‚ã‚‹å ´åˆ
    if (typeof error === 'object' && error !== null) {
      const errorObj = error as any;
      if (typeof errorObj.message === 'string') {
        return errorObj.message || defaultMessage;
      }
      // OperationResult å½¢å¼ã®å ´åˆ
      if (typeof errorObj.message === 'string' && errorObj.success === false) {
        return errorObj.message || defaultMessage;
      }
    }

    return defaultMessage;
  }

  /**
   * çµ±ä¸€ã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼ãƒ­ã‚°å‡ºåŠ›
   *
   * @param context - ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
   * @param error - ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
   * @param additionalInfo - è¿½åŠ æƒ…å ±
   */
  static logError(
    context: string,
    error: unknown,
    additionalInfo?: Record<string, any>
  ): void {
    const timestamp = new Date().toISOString();
    console.group(`âŒ [${timestamp}] ${context}`);

    if (error instanceof Error) {
      console.error('Error:', error.message);
      console.error('Stack:', error.stack);
    } else {
      console.error('Error:', error);
    }

    if (additionalInfo) {
      console.error('Additional Info:', additionalInfo);
    }

    console.groupEnd();
  }

  /**
   * çµ±ä¸€ã•ã‚ŒãŸè­¦å‘Šãƒ­ã‚°å‡ºåŠ›
   *
   * @param context - è­¦å‘ŠãŒç™ºç”Ÿã—ãŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
   * @param message - è­¦å‘Šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
   * @param additionalInfo - è¿½åŠ æƒ…å ±
   */
  static logWarning(
    context: string,
    message: string,
    additionalInfo?: Record<string, any>
  ): void {
    const timestamp = new Date().toISOString();
    console.group(`âš ï¸ [${timestamp}] ${context}`);
    console.warn('Warning:', message);

    if (additionalInfo) {
      console.warn('Additional Info:', additionalInfo);
    }

    console.groupEnd();
  }

  /**
   * çµ±ä¸€ã•ã‚ŒãŸæƒ…å ±ãƒ­ã‚°å‡ºåŠ›
   *
   * @param context - ãƒ­ã‚°ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
   * @param message - æƒ…å ±ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
   * @param additionalInfo - è¿½åŠ æƒ…å ±
   */
  static logInfo(
    context: string,
    message: string,
    additionalInfo?: Record<string, any>
  ): void {
    const timestamp = new Date().toISOString();
    console.log(`â„¹ï¸ [${timestamp}] ${context}: ${message}`);

    if (additionalInfo) {
      console.log('Additional Info:', additionalInfo);
    }
  }
}

/**
 * React ãƒ•ãƒƒã‚¯ã§ã®ä¾¿åˆ©ãªãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
 */

/**
 * ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä»˜ãã®éåŒæœŸæ“ä½œãƒ•ãƒƒã‚¯
 *
 * @param defaultErrorMessage - ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
 * @returns ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ç”¨ã®é–¢æ•°ã¨ã‚¹ãƒ†ãƒ¼ãƒˆ
 *
 * @example
 * ```typescript
 * const MyComponent = () => {
 *   const { executeAsync, isLoading, error, clearError } = useAsyncErrorHandler('æ“ä½œã«å¤±æ•—ã—ã¾ã—ãŸ');
 *
 *   const handleSave = () => {
 *     executeAsync(
 *       () => saveData(),
 *       { operationName: 'ä¿å­˜' }
 *     );
 *   };
 *
 *   return (
 *     <div>
 *       {error && <div className="error">{error}</div>}
 *       <button onClick={handleSave} disabled={isLoading}>
 *         {isLoading ? 'ä¿å­˜ä¸­...' : 'ä¿å­˜'}
 *       </button>
 *     </div>
 *   );
 * };
 * ```
 */
export function useAsyncErrorHandler(defaultErrorMessage?: string) {
  const [isLoading, setIsLoading] = React.useState(false);
  const [error, setError] = React.useState<string>('');

  const executeAsync = React.useCallback(
    async <T>(
      operation: () => Promise<T>,
      options: Partial<ErrorHandlingOptions> = {}
    ): Promise<T | null> => {
      const result = await ErrorHandler.handleAsync(operation, {
        onError: setError,
        setLoading: setIsLoading,
        defaultErrorMessage,
        ...options,
      });

      return result;
    },
    [defaultErrorMessage]
  );

  const executeOperationResult = React.useCallback(
    async <T>(
      operation: () => Promise<OperationResult<T>>,
      options: Partial<ErrorHandlingOptions> = {}
    ): Promise<OperationResult<T>> => {
      const result = await ErrorHandler.handleOperationResult(operation, {
        onError: setError,
        setLoading: setIsLoading,
        defaultErrorMessage,
        ...options,
      });

      return result;
    },
    [defaultErrorMessage]
  );

  const clearError = React.useCallback(() => {
    setError('');
  }, []);

  return {
    executeAsync,
    executeOperationResult,
    isLoading,
    error,
    clearError,
    setError,
  };
}

/**
 * ãƒ¬ã‚¬ã‚·ãƒ¼äº’æ›æ€§ã®ãŸã‚ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
 */

/**
 * @deprecated ErrorHandler.handleAsync() ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„
 */
export async function handleAsyncError<T>(
  asyncFn: () => Promise<T>,
  onError: (msg: string) => void
): Promise<T | null> {
  return ErrorHandler.handleAsync(asyncFn, {
    onError,
    defaultErrorMessage: 'æ“ä½œã«å¤±æ•—ã—ã¾ã—ãŸ',
  });
}

/**
 * @deprecated ErrorHandler.extractErrorMessage() ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„
 */
export function getErrorMessage(
  error: unknown,
  defaultMessage: string = 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼'
): string {
  return ErrorHandler.extractErrorMessage(error, defaultMessage);
}
