<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>学習モード ダイアグラムカタログ</title>
    <style>
        /* カラーシステム（プロジェクトに合わせる） */
        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #2a2a2a;
            --text-primary: #ffffff;
            --text-secondary: #aaaaaa;
            --accent-green: #00ff88;
            --accent-red: #ff6b6b;
            --accent-blue: #4ecdc4;
            --accent-yellow: #ffd93d;
            --accent-orange: #ff9500;
            --wire-inactive: #666666;
            --border-color: #333333;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Hiragino Sans", sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        h1 {
            text-align: center;
            color: var(--accent-green);
            margin-bottom: 3rem;
            font-size: 2.5rem;
        }
        
        .category {
            margin-bottom: 4rem;
        }
        
        .category-title {
            color: var(--accent-green);
            font-size: 2rem;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border-color);
        }
        
        .diagram-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 2rem;
        }
        
        .diagram-card {
            background: var(--bg-secondary);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            transition: transform 0.3s;
        }
        
        .diagram-card:hover {
            transform: translateY(-4px);
        }
        
        .diagram-header {
            background: var(--bg-tertiary);
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        
        .diagram-title {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }
        
        .diagram-description {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        
        .canvas-wrapper {
            background: var(--bg-primary);
            padding: 2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 250px;
        }
        
        canvas {
            display: block;
            max-width: 100%;
            height: auto;
        }
        
        /* 凡例・ラベル */
        .legend {
            padding: 1rem 1.5rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap;
            justify-content: center;
            background: rgba(0,0,0,0.3);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        
        /* インタラクティブコントロール */
        .controls {
            padding: 1rem 1.5rem;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: 1rem;
            align-items: center;
            justify-content: center;
        }
        
        button {
            background: var(--accent-green);
            color: var(--bg-primary);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #00cc66;
        }
        
        input[type="range"] {
            width: 150px;
        }
        
        .status {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: var(--accent-green);
            color: var(--bg-primary);
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
        }
        
        .status.new {
            background: var(--accent-blue);
        }
        
        /* テーブルスタイル */
        .table-wrapper {
            padding: 1rem 1.5rem;
            overflow-x: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-family: monospace;
        }
        
        th, td {
            padding: 0.75rem;
            text-align: center;
            border: 1px solid var(--border-color);
        }
        
        th {
            background: var(--bg-tertiary);
            color: var(--accent-green);
            font-weight: bold;
        }
        
        td {
            background: var(--bg-primary);
        }
        
        .truth-1 {
            background: var(--accent-green) !important;
            color: var(--bg-primary);
            font-weight: bold;
        }
        
        @media (max-width: 768px) {
            .diagram-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>学習モード ダイアグラムカタログ</h1>
        
        <!-- カテゴリ1: 基本ゲート記号 -->
        <section class="category">
            <h2 class="category-title">1. 基本ゲート記号</h2>
            <div class="diagram-grid">
                
                <!-- ANDゲート -->
                <div class="diagram-card">
                    <div class="diagram-header">
                        <h3 class="diagram-title">ANDゲート</h3>
                        <p class="diagram-description">すべての入力が1のときのみ出力が1</p>
                    </div>
                    <div class="canvas-wrapper">
                        <canvas id="andGate" width="300" height="200"></canvas>
                    </div>
                    <div class="table-wrapper">
                        <table>
                            <tr><th>A</th><th>B</th><th>Y</th></tr>
                            <tr><td>0</td><td>0</td><td>0</td></tr>
                            <tr><td>0</td><td>1</td><td>0</td></tr>
                            <tr><td>1</td><td>0</td><td>0</td></tr>
                            <tr><td>1</td><td>1</td><td class="truth-1">1</td></tr>
                        </table>
                    </div>
                </div>
                
                <!-- ORゲート -->
                <div class="diagram-card">
                    <div class="diagram-header">
                        <h3 class="diagram-title">ORゲート</h3>
                        <p class="diagram-description">少なくとも1つの入力が1なら出力が1</p>
                    </div>
                    <div class="canvas-wrapper">
                        <canvas id="orGate" width="300" height="200"></canvas>
                    </div>
                    <div class="table-wrapper">
                        <table>
                            <tr><th>A</th><th>B</th><th>Y</th></tr>
                            <tr><td>0</td><td>0</td><td>0</td></tr>
                            <tr><td>0</td><td>1</td><td class="truth-1">1</td></tr>
                            <tr><td>1</td><td>0</td><td class="truth-1">1</td></tr>
                            <tr><td>1</td><td>1</td><td class="truth-1">1</td></tr>
                        </table>
                    </div>
                </div>
                
                <!-- NOTゲート -->
                <div class="diagram-card">
                    <div class="diagram-header">
                        <h3 class="diagram-title">NOTゲート</h3>
                        <p class="diagram-description">入力を反転（0→1、1→0）</p>
                    </div>
                    <div class="canvas-wrapper">
                        <canvas id="notGate" width="300" height="200"></canvas>
                    </div>
                    <div class="table-wrapper">
                        <table>
                            <tr><th>A</th><th>Y</th></tr>
                            <tr><td>0</td><td class="truth-1">1</td></tr>
                            <tr><td>1</td><td>0</td></tr>
                        </table>
                    </div>
                </div>
                
                <!-- XORゲート -->
                <div class="diagram-card">
                    <div class="diagram-header">
                        <h3 class="diagram-title">XORゲート</h3>
                        <p class="diagram-description">入力が異なるときのみ出力が1</p>
                    </div>
                    <div class="canvas-wrapper">
                        <canvas id="xorGate" width="300" height="200"></canvas>
                    </div>
                    <div class="table-wrapper">
                        <table>
                            <tr><th>A</th><th>B</th><th>Y</th></tr>
                            <tr><td>0</td><td>0</td><td>0</td></tr>
                            <tr><td>0</td><td>1</td><td class="truth-1">1</td></tr>
                            <tr><td>1</td><td>0</td><td class="truth-1">1</td></tr>
                            <tr><td>1</td><td>1</td><td>0</td></tr>
                        </table>
                    </div>
                </div>
                
            </div>
        </section>
        
        <!-- カテゴリ2: 波形・信号 -->
        <section class="category">
            <h2 class="category-title">2. 波形・信号</h2>
            <div class="diagram-grid">
                
                <!-- アナログ vs デジタル -->
                <div class="diagram-card">
                    <div class="diagram-header">
                        <h3 class="diagram-title">アナログ vs デジタル信号</h3>
                        <p class="diagram-description">連続的な変化と離散的な2値の比較</p>
                    </div>
                    <div class="canvas-wrapper">
                        <canvas id="analogVsDigital" width="400" height="250"></canvas>
                    </div>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: var(--accent-orange);"></div>
                            <span>アナログ信号（連続）</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: var(--accent-green);"></div>
                            <span>デジタル信号（0/1）</span>
                        </div>
                    </div>
                </div>
                
                <!-- クロック信号 -->
                <div class="diagram-card">
                    <div class="diagram-header">
                        <h3 class="diagram-title">クロック信号</h3>
                        <p class="diagram-description">一定周期で変化する同期信号</p>
                        <span class="status new">アニメーション</span>
                    </div>
                    <div class="canvas-wrapper">
                        <canvas id="clockSignal" width="400" height="200"></canvas>
                    </div>
                    <div class="controls">
                        <button onclick="toggleClock()">開始/停止</button>
                        <label>周波数: <input type="range" id="clockFreq" min="1" max="10" value="5"></label>
                    </div>
                </div>
                
                <!-- タイミングチャート -->
                <div class="diagram-card">
                    <div class="diagram-header">
                        <h3 class="diagram-title">D-FFタイミングチャート</h3>
                        <p class="diagram-description">CLK、D、Q信号の時間関係</p>
                    </div>
                    <div class="canvas-wrapper">
                        <canvas id="timingChart" width="400" height="250"></canvas>
                    </div>
                    <div class="legend">
                        <div class="legend-item">
                            <span style="color: var(--accent-blue);">CLK</span>
                        </div>
                        <div class="legend-item">
                            <span style="color: var(--accent-orange);">D (入力)</span>
                        </div>
                        <div class="legend-item">
                            <span style="color: var(--accent-green);">Q (出力)</span>
                        </div>
                    </div>
                </div>
                
            </div>
        </section>
        
        <!-- カテゴリ3: 回路接続 -->
        <section class="category">
            <h2 class="category-title">3. 回路接続図</h2>
            <div class="diagram-grid">
                
                <!-- 簡単な接続 -->
                <div class="diagram-card">
                    <div class="diagram-header">
                        <h3 class="diagram-title">基本的な接続</h3>
                        <p class="diagram-description">2つのゲートの接続例</p>
                    </div>
                    <div class="canvas-wrapper">
                        <canvas id="simpleConnection" width="400" height="200"></canvas>
                    </div>
                </div>
                
                <!-- 半加算器 -->
                <div class="diagram-card">
                    <div class="diagram-header">
                        <h3 class="diagram-title">半加算器</h3>
                        <p class="diagram-description">XORとANDで構成される1ビット加算器</p>
                    </div>
                    <div class="canvas-wrapper">
                        <canvas id="halfAdder" width="400" height="250"></canvas>
                    </div>
                    <div class="table-wrapper">
                        <table>
                            <tr><th>A</th><th>B</th><th>Sum</th><th>Carry</th></tr>
                            <tr><td>0</td><td>0</td><td>0</td><td>0</td></tr>
                            <tr><td>0</td><td>1</td><td class="truth-1">1</td><td>0</td></tr>
                            <tr><td>1</td><td>0</td><td class="truth-1">1</td><td>0</td></tr>
                            <tr><td>1</td><td>1</td><td>0</td><td class="truth-1">1</td></tr>
                        </table>
                    </div>
                </div>
                
            </div>
        </section>
        
        <!-- カテゴリ4: データ表現 -->
        <section class="category">
            <h2 class="category-title">4. データ表現</h2>
            <div class="diagram-grid">
                
                <!-- ビット配列 -->
                <div class="diagram-card">
                    <div class="diagram-header">
                        <h3 class="diagram-title">4ビット加算の視覚化</h3>
                        <p class="diagram-description">繰り上がりを含む加算過程</p>
                    </div>
                    <div class="canvas-wrapper">
                        <canvas id="bitAddition" width="400" height="250"></canvas>
                    </div>
                    <div class="controls">
                        <button onclick="animateAddition()">加算アニメーション</button>
                    </div>
                </div>
                
                <!-- キャリー伝播 -->
                <div class="diagram-card">
                    <div class="diagram-header">
                        <h3 class="diagram-title">キャリー伝播遅延</h3>
                        <p class="diagram-description">繰り上がり信号の伝播を視覚化</p>
                    </div>
                    <div class="canvas-wrapper">
                        <canvas id="carryPropagation" width="400" height="200"></canvas>
                    </div>
                </div>
                
            </div>
        </section>
        
    </div>
    
    <script>
        // Canvas設定ヘルパー
        function setupCanvas(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            
            // 高DPI対応
            const rect = canvas.getBoundingClientRect();
            canvas.width = canvas.width * dpr;
            canvas.height = canvas.height * dpr;
            ctx.scale(dpr, dpr);
            
            return ctx;
        }
        
        // 共通の色設定
        const colors = {
            bg: '#0a0a0a',
            gate: '#1a1a1a',
            wire: '#666666',
            wireActive: '#00ff88',
            text: '#ffffff',
            analog: '#ff9500',
            digital: '#00ff88',
            clock: '#4ecdc4'
        };
        
        // 1. 基本ゲート記号の描画
        function drawGateSymbol(ctx, type, x, y, width = 80, height = 60) {
            ctx.save();
            
            // ゲート本体
            ctx.fillStyle = colors.gate;
            ctx.strokeStyle = colors.wireActive;
            ctx.lineWidth = 2;
            
            switch(type) {
                case 'AND':
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + width/2, y);
                    ctx.arc(x + width/2, y + height/2, height/2, -Math.PI/2, Math.PI/2);
                    ctx.lineTo(x, y + height);
                    ctx.closePath();
                    break;
                    
                case 'OR':
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.quadraticCurveTo(x + width/3, y + height/2, x, y + height);
                    ctx.quadraticCurveTo(x + width/2, y + height, x + width, y + height/2);
                    ctx.quadraticCurveTo(x + width/2, y, x, y);
                    break;
                    
                case 'NOT':
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + width - 10, y + height/2);
                    ctx.lineTo(x, y + height);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    // 反転を示す円
                    ctx.beginPath();
                    ctx.arc(x + width - 5, y + height/2, 5, 0, Math.PI * 2);
                    break;
                    
                case 'XOR':
                    // ORゲートの形状
                    ctx.beginPath();
                    ctx.moveTo(x + 10, y);
                    ctx.quadraticCurveTo(x + width/3 + 10, y + height/2, x + 10, y + height);
                    ctx.quadraticCurveTo(x + width/2 + 10, y + height, x + width, y + height/2);
                    ctx.quadraticCurveTo(x + width/2 + 10, y, x + 10, y);
                    ctx.fill();
                    ctx.stroke();
                    // 追加の曲線
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.quadraticCurveTo(x + 20, y + height/2, x, y + height);
                    ctx.stroke();
                    ctx.restore();
                    return;
            }
            
            ctx.fill();
            ctx.stroke();
            
            // ラベル
            ctx.fillStyle = colors.text;
            ctx.font = 'bold 16px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            if (type === 'NOT') {
                ctx.fillText(type, x + width/2 - 10, y + height/2);
            } else {
                ctx.fillText(type, x + width/2, y + height/2);
            }
            
            ctx.restore();
        }
        
        // ANDゲートを描画
        function drawAndGate() {
            const ctx = setupCanvas('andGate');
            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, 300, 200);
            
            drawGateSymbol(ctx, 'AND', 110, 70);
            
            // 入力線
            ctx.strokeStyle = colors.wire;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, 90);
            ctx.lineTo(110, 90);
            ctx.moveTo(50, 110);
            ctx.lineTo(110, 110);
            ctx.stroke();
            
            // 出力線
            ctx.strokeStyle = colors.wireActive;
            ctx.beginPath();
            ctx.moveTo(190, 100);
            ctx.lineTo(250, 100);
            ctx.stroke();
            
            // ピンラベル
            ctx.fillStyle = colors.text;
            ctx.font = '14px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('A', 40, 90);
            ctx.fillText('B', 40, 110);
            ctx.fillText('Y', 260, 100);
        }
        
        // ORゲートを描画
        function drawOrGate() {
            const ctx = setupCanvas('orGate');
            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, 300, 200);
            
            drawGateSymbol(ctx, 'OR', 110, 70);
            
            // 配線は省略（同様のパターン）
            ctx.strokeStyle = colors.wire;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, 90);
            ctx.lineTo(110, 90);
            ctx.moveTo(50, 110);
            ctx.lineTo(110, 110);
            ctx.stroke();
            
            ctx.strokeStyle = colors.wireActive;
            ctx.beginPath();
            ctx.moveTo(190, 100);
            ctx.lineTo(250, 100);
            ctx.stroke();
            
            ctx.fillStyle = colors.text;
            ctx.font = '14px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('A', 40, 90);
            ctx.fillText('B', 40, 110);
            ctx.fillText('Y', 260, 100);
        }
        
        // NOTゲートを描画
        function drawNotGate() {
            const ctx = setupCanvas('notGate');
            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, 300, 200);
            
            drawGateSymbol(ctx, 'NOT', 110, 70);
            
            ctx.strokeStyle = colors.wire;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, 100);
            ctx.lineTo(110, 100);
            ctx.stroke();
            
            ctx.strokeStyle = colors.wireActive;
            ctx.beginPath();
            ctx.moveTo(195, 100);
            ctx.lineTo(250, 100);
            ctx.stroke();
            
            ctx.fillStyle = colors.text;
            ctx.font = '14px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('A', 40, 100);
            ctx.fillText('Y', 260, 100);
        }
        
        // XORゲートを描画
        function drawXorGate() {
            const ctx = setupCanvas('xorGate');
            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, 300, 200);
            
            drawGateSymbol(ctx, 'XOR', 110, 70);
            
            ctx.strokeStyle = colors.wire;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, 90);
            ctx.lineTo(110, 90);
            ctx.moveTo(50, 110);
            ctx.lineTo(110, 110);
            ctx.stroke();
            
            ctx.strokeStyle = colors.wireActive;
            ctx.beginPath();
            ctx.moveTo(190, 100);
            ctx.lineTo(250, 100);
            ctx.stroke();
            
            ctx.fillStyle = colors.text;
            ctx.font = '14px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('A', 40, 90);
            ctx.fillText('B', 40, 110);
            ctx.fillText('Y', 260, 100);
        }
        
        // 2. アナログ vs デジタル信号
        function drawAnalogVsDigital() {
            const ctx = setupCanvas('analogVsDigital');
            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, 400, 250);
            
            // グリッド
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 8; i++) {
                const x = 50 + i * 40;
                ctx.beginPath();
                ctx.moveTo(x, 30);
                ctx.lineTo(x, 220);
                ctx.stroke();
            }
            
            // アナログ信号
            ctx.strokeStyle = colors.analog;
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let x = 50; x <= 370; x += 2) {
                const t = (x - 50) / 320;
                const y = 80 + Math.sin(t * Math.PI * 4) * 30 * (1 + 0.3 * Math.cos(t * Math.PI * 2));
                if (x === 50) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // デジタル信号
            ctx.strokeStyle = colors.digital;
            ctx.lineWidth = 3;
            ctx.beginPath();
            const bits = [1, 0, 0, 1, 1, 0, 1, 0];
            bits.forEach((bit, i) => {
                const x1 = 50 + i * 40;
                const x2 = x1 + 40;
                const y = bit ? 140 : 190;
                
                if (i === 0) {
                    ctx.moveTo(x1, y);
                } else {
                    const prevY = bits[i-1] ? 140 : 190;
                    if (y !== prevY) {
                        ctx.lineTo(x1, prevY);
                        ctx.lineTo(x1, y);
                    }
                }
                ctx.lineTo(x2, y);
                
                // ビット値
                ctx.save();
                ctx.font = '12px monospace';
                ctx.fillStyle = colors.digital;
                ctx.textAlign = 'center';
                ctx.fillText(bit.toString(), x1 + 20, 130);
                ctx.restore();
            });
            ctx.stroke();
            
            // ラベル（最小限）
            ctx.fillStyle = colors.analog;
            ctx.font = '14px sans-serif';
            ctx.fillText('アナログ', 10, 80);
            
            ctx.fillStyle = colors.digital;
            ctx.fillText('デジタル', 10, 165);
        }
        
        // 3. クロック信号（アニメーション）
        let clockAnimation = null;
        let clockPhase = 0;
        
        function drawClockSignal() {
            const ctx = setupCanvas('clockSignal');
            const freq = document.getElementById('clockFreq').value / 10;
            
            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, 400, 200);
            
            // グリッド
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = 40 + i * 32;
                ctx.beginPath();
                ctx.moveTo(x, 30);
                ctx.lineTo(x, 170);
                ctx.stroke();
            }
            
            // クロック波形
            ctx.strokeStyle = colors.clock;
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let i = 0; i < 10; i++) {
                const x = 40 + i * 32;
                const phase = (i + clockPhase * freq) % 2;
                const y = phase < 1 ? 50 : 150;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    const prevPhase = (i - 1 + clockPhase * freq) % 2;
                    const prevY = prevPhase < 1 ? 50 : 150;
                    if (y !== prevY) {
                        ctx.lineTo(x, prevY);
                        ctx.lineTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
            }
            ctx.stroke();
            
            // ラベル
            ctx.fillStyle = colors.clock;
            ctx.font = '16px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('CLK', 200, 20);
        }
        
        function animateClock() {
            clockPhase += 0.02;
            drawClockSignal();
            clockAnimation = requestAnimationFrame(animateClock);
        }
        
        function toggleClock() {
            if (clockAnimation) {
                cancelAnimationFrame(clockAnimation);
                clockAnimation = null;
            } else {
                animateClock();
            }
        }
        
        // 4. タイミングチャート
        function drawTimingChart() {
            const ctx = setupCanvas('timingChart');
            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, 400, 250);
            
            const signals = [
                { name: 'CLK', data: [0,1,0,1,0,1,0,1,0,1], color: colors.clock, y: 50 },
                { name: 'D', data: [0,0,1,1,1,0,0,0,1,1], color: colors.analog, y: 120 },
                { name: 'Q', data: [0,0,0,1,1,1,0,0,0,1], color: colors.digital, y: 190 }
            ];
            
            // 各信号を描画
            signals.forEach(signal => {
                ctx.strokeStyle = signal.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                signal.data.forEach((bit, i) => {
                    const x1 = 50 + i * 35;
                    const x2 = x1 + 35;
                    const y = signal.y + (bit ? -20 : 20);
                    
                    if (i === 0) {
                        ctx.moveTo(x1, y);
                    } else {
                        const prevY = signal.y + (signal.data[i-1] ? -20 : 20);
                        if (y !== prevY) {
                            ctx.lineTo(x1, prevY);
                            ctx.lineTo(x1, y);
                        }
                    }
                    ctx.lineTo(x2, y);
                });
                ctx.stroke();
                
                // 信号名
                ctx.fillStyle = signal.color;
                ctx.font = '14px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(signal.name, 40, signal.y);
            });
            
            // 立ち上がりエッジマーカー
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            for (let i = 1; i < 10; i += 2) {
                const x = 50 + i * 35;
                ctx.beginPath();
                ctx.moveTo(x, 30);
                ctx.lineTo(x, 210);
                ctx.stroke();
            }
            ctx.setLineDash([]);
        }
        
        // 5. 基本的な接続
        function drawSimpleConnection() {
            const ctx = setupCanvas('simpleConnection');
            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, 400, 200);
            
            // NOTゲート
            drawGateSymbol(ctx, 'NOT', 80, 70);
            
            // ANDゲート
            drawGateSymbol(ctx, 'AND', 220, 70);
            
            // 接続線
            ctx.strokeStyle = colors.wireActive;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(165, 100);
            ctx.lineTo(220, 90);
            ctx.stroke();
            
            // 入力線
            ctx.strokeStyle = colors.wire;
            ctx.beginPath();
            ctx.moveTo(30, 100);
            ctx.lineTo(80, 100);
            ctx.moveTo(30, 110);
            ctx.lineTo(190, 110);
            ctx.lineTo(220, 110);
            ctx.stroke();
            
            // 出力線
            ctx.strokeStyle = colors.wireActive;
            ctx.beginPath();
            ctx.moveTo(300, 100);
            ctx.lineTo(370, 100);
            ctx.stroke();
        }
        
        // 6. 半加算器
        function drawHalfAdder() {
            const ctx = setupCanvas('halfAdder');
            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, 400, 250);
            
            // XORゲート（Sum用）
            drawGateSymbol(ctx, 'XOR', 180, 50);
            
            // ANDゲート（Carry用）
            drawGateSymbol(ctx, 'AND', 180, 140);
            
            // 入力の分岐
            ctx.strokeStyle = colors.wire;
            ctx.lineWidth = 2;
            
            // A入力
            ctx.beginPath();
            ctx.moveTo(50, 80);
            ctx.lineTo(100, 80);
            ctx.moveTo(100, 80);
            ctx.lineTo(100, 160);
            ctx.moveTo(100, 80);
            ctx.lineTo(180, 80);
            ctx.moveTo(100, 160);
            ctx.lineTo(180, 160);
            ctx.stroke();
            
            // B入力
            ctx.beginPath();
            ctx.moveTo(50, 120);
            ctx.lineTo(120, 120);
            ctx.moveTo(120, 120);
            ctx.lineTo(120, 100);
            ctx.lineTo(180, 100);
            ctx.moveTo(120, 120);
            ctx.lineTo(120, 180);
            ctx.lineTo(180, 180);
            ctx.stroke();
            
            // 出力
            ctx.strokeStyle = colors.wireActive;
            ctx.beginPath();
            ctx.moveTo(260, 80);
            ctx.lineTo(350, 80);
            ctx.moveTo(260, 170);
            ctx.lineTo(350, 170);
            ctx.stroke();
            
            // ラベル
            ctx.fillStyle = colors.text;
            ctx.font = '14px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('A', 40, 80);
            ctx.fillText('B', 40, 120);
            ctx.fillText('Sum', 370, 80);
            ctx.fillText('Carry', 370, 170);
        }
        
        // 7. ビット加算アニメーション
        let additionStep = 0;
        
        function drawBitAddition() {
            const ctx = setupCanvas('bitAddition');
            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, 400, 250);
            
            // 加算例: 0101 + 0011 = 1000
            const a = [0, 1, 0, 1];
            const b = [0, 0, 1, 1];
            const sum = [1, 0, 0, 0];
            const carry = [0, 1, 1, 0];
            
            // ビット表示
            for (let i = 0; i < 4; i++) {
                const x = 100 + i * 60;
                
                // A
                ctx.fillStyle = i <= additionStep ? colors.analog : '#333';
                ctx.fillRect(x, 50, 40, 30);
                ctx.fillStyle = colors.text;
                ctx.font = '16px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(a[3-i].toString(), x + 20, 70);
                
                // B
                ctx.fillStyle = i <= additionStep ? colors.clock : '#333';
                ctx.fillRect(x, 90, 40, 30);
                ctx.fillStyle = colors.text;
                ctx.fillText(b[3-i].toString(), x + 20, 110);
                
                // 結果
                if (i <= additionStep) {
                    ctx.fillStyle = colors.digital;
                    ctx.fillRect(x, 150, 40, 30);
                    ctx.fillStyle = colors.bg;
                    ctx.fillText(sum[3-i].toString(), x + 20, 170);
                    
                    // キャリー
                    if (carry[3-i] && i < 3) {
                        ctx.fillStyle = colors.wireActive;
                        ctx.font = '12px monospace';
                        ctx.fillText('↗', x + 40, 140);
                    }
                }
            }
            
            // プラス記号
            ctx.fillStyle = colors.text;
            ctx.font = '20px monospace';
            ctx.fillText('+', 70, 105);
            
            // イコール
            ctx.strokeStyle = colors.text;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, 140);
            ctx.lineTo(350, 140);
            ctx.stroke();
        }
        
        function animateAddition() {
            additionStep = 0;
            const animate = () => {
                drawBitAddition();
                additionStep++;
                if (additionStep < 4) {
                    setTimeout(animate, 500);
                }
            };
            animate();
        }
        
        // 8. キャリー伝播
        function drawCarryPropagation() {
            const ctx = setupCanvas('carryPropagation');
            ctx.fillStyle = colors.bg;
            ctx.fillRect(0, 0, 400, 200);
            
            // 4つの全加算器
            for (let i = 0; i < 4; i++) {
                const x = 50 + i * 80;
                
                // FA box
                ctx.fillStyle = colors.gate;
                ctx.strokeStyle = colors.wireActive;
                ctx.lineWidth = 2;
                ctx.fillRect(x, 60, 60, 80);
                ctx.strokeRect(x, 60, 60, 80);
                
                // ラベル
                ctx.fillStyle = colors.text;
                ctx.font = '14px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(`FA${i}`, x + 30, 100);
                
                // キャリー線
                if (i < 3) {
                    ctx.strokeStyle = colors.wireActive;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x + 60, 120);
                    ctx.lineTo(x + 80, 120);
                    ctx.stroke();
                    
                    // 遅延表示
                    ctx.fillStyle = colors.analog;
                    ctx.font = '10px monospace';
                    ctx.fillText(`${i+1}Δ`, x + 70, 110);
                }
            }
            
            // 遅延の累積を示す矢印
            ctx.strokeStyle = colors.analog;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, 160);
            ctx.lineTo(350, 160);
            ctx.stroke();
            
            // 矢印の頭
            ctx.beginPath();
            ctx.moveTo(340, 155);
            ctx.lineTo(350, 160);
            ctx.lineTo(340, 165);
            ctx.stroke();
            
            ctx.fillStyle = colors.analog;
            ctx.font = '12px monospace';
            ctx.textAlign = 'center';
            ctx.fillText('キャリー伝播遅延', 200, 180);
        }
        
        // 初期描画
        drawAndGate();
        drawOrGate();
        drawNotGate();
        drawXorGate();
        drawAnalogVsDigital();
        drawClockSignal();
        drawTimingChart();
        drawSimpleConnection();
        drawHalfAdder();
        drawBitAddition();
        drawCarryPropagation();
        
        // イベントリスナー
        document.getElementById('clockFreq').addEventListener('input', drawClockSignal);
    </script>
</body>
</html>