<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas API改善版 - テキスト問題解決</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Hiragino Sans", "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif;
            margin: 20px;
            background: #0a0a0a;
            color: #ffffff;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .demo-section {
            background: #1a1a1a;
            padding: 30px;
            margin: 20px 0;
            border-radius: 12px;
        }
        h2 {
            color: #00ff88;
            margin-bottom: 20px;
        }
        canvas {
            border: 1px solid #333;
            display: block;
            margin: 0 auto;
        }
        .issue-fix {
            background: #2a2a2a;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border-left: 4px solid #00ff88;
        }
        .issue {
            color: #ff6b6b;
        }
        .solution {
            color: #00ff88;
        }
        code {
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 style="text-align: center; color: #00ff88;">Canvas API改善版 - 文字化け・重なり問題の解決</h1>
        
        <!-- 問題と解決策の説明 -->
        <div class="issue-fix">
            <h3>特定された問題と解決策</h3>
            <ol>
                <li>
                    <span class="issue">問題：</span> 日本語フォントの指定が不適切で文字化け<br>
                    <span class="solution">解決：</span> <code>font-family</code>に日本語フォントを明示的に指定
                </li>
                <li>
                    <span class="issue">問題：</span> テキストと図形の重なり<br>
                    <span class="solution">解決：</span> <code>measureText()</code>でテキスト幅を測定し、適切な間隔を確保
                </li>
                <li>
                    <span class="issue">問題：</span> 高DPIディスプレイでのぼやけ<br>
                    <span class="solution">解決：</span> <code>devicePixelRatio</code>を考慮したスケーリング
                </li>
            </ol>
        </div>

        <!-- デモ1: テキストレンダリング改善 -->
        <div class="demo-section">
            <h2>デモ1: 改善されたテキストレンダリング</h2>
            <canvas id="textDemo" width="800" height="300"></canvas>
        </div>

        <!-- デモ2: レイアウト改善版 -->
        <div class="demo-section">
            <h2>デモ2: 重なり問題を解決したアナログvsデジタル</h2>
            <canvas id="layoutDemo" width="800" height="500"></canvas>
        </div>

        <!-- デモ3: 高DPI対応版 -->
        <div class="demo-section">
            <h2>デモ3: 高DPI対応で鮮明な表示</h2>
            <canvas id="hdpiDemo" width="800" height="400"></canvas>
        </div>

        <!-- デモ4: 実用的な比較図 -->
        <div class="demo-section">
            <h2>デモ4: 学習モード用の実用的な比較図</h2>
            <canvas id="practicalDemo" width="900" height="600"></canvas>
        </div>
    </div>

    <script>
        // Canvas初期化ヘルパー（高DPI対応）
        function setupCanvas(canvas) {
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            
            // 実際のサイズを設定
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            
            // CSSサイズを維持
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            
            // スケーリング
            ctx.scale(dpr, dpr);
            
            return ctx;
        }

        // 安全なテキスト描画関数
        function drawText(ctx, text, x, y, options = {}) {
            const {
                font = '16px',
                fontFamily = '"Hiragino Sans", "Hiragino Kaku Gothic ProN", "Meiryo", -apple-system, sans-serif',
                color = '#ffffff',
                align = 'left',
                baseline = 'alphabetic',
                maxWidth = null,
                background = null,
                padding = 5
            } = options;
            
            ctx.save();
            
            // フォント設定（日本語対応）
            ctx.font = `${font} ${fontFamily}`;
            ctx.fillStyle = color;
            ctx.textAlign = align;
            ctx.textBaseline = baseline;
            
            // テキスト幅を測定
            const metrics = ctx.measureText(text);
            const textWidth = metrics.width;
            const textHeight = parseInt(font); // 簡易的な高さ推定
            
            // 背景を描画（オプション）
            if (background) {
                ctx.fillStyle = background;
                const bgX = align === 'center' ? x - textWidth/2 - padding : 
                           align === 'right' ? x - textWidth - padding : x - padding;
                const bgY = baseline === 'middle' ? y - textHeight/2 - padding :
                           baseline === 'bottom' ? y - textHeight - padding : y - padding;
                ctx.fillRect(bgX, bgY, textWidth + padding*2, textHeight + padding*2);
                ctx.fillStyle = color;
            }
            
            // テキスト描画
            if (maxWidth) {
                ctx.fillText(text, x, y, maxWidth);
            } else {
                ctx.fillText(text, x, y);
            }
            
            ctx.restore();
            
            return { width: textWidth, height: textHeight };
        }

        // デモ1: テキストレンダリング改善
        function drawTextDemo() {
            const canvas = document.getElementById('textDemo');
            const ctx = setupCanvas(canvas);
            const width = canvas.getBoundingClientRect().width;
            const height = canvas.getBoundingClientRect().height;
            
            // 背景
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);
            
            // 各種フォントテスト
            const tests = [
                { text: '文字化けしない日本語表示', font: 'bold 24px', y: 50 },
                { text: 'アナログ信号 vs デジタル信号', font: '20px', y: 100 },
                { text: '閾値: 2.5V（可変）', font: '16px', y: 150 },
                { text: '0と1の2値のみを扱う', font: '18px', y: 200 },
                { text: 'HIGH = 1, LOW = 0', font: '16px', y: 250, fontFamily: 'monospace' }
            ];
            
            tests.forEach(test => {
                drawText(ctx, test.text, 50, test.y, {
                    font: test.font,
                    fontFamily: test.fontFamily,
                    color: '#00ff88'
                });
                
                // 測定結果を表示
                const metrics = ctx.measureText(test.text);
                drawText(ctx, `幅: ${Math.round(metrics.width)}px`, 600, test.y, {
                    font: '12px',
                    color: '#666666'
                });
            });
        }

        // デモ2: レイアウト改善版
        function drawLayoutDemo() {
            const canvas = document.getElementById('layoutDemo');
            const ctx = setupCanvas(canvas);
            const width = canvas.getBoundingClientRect().width;
            const height = canvas.getBoundingClientRect().height;
            
            // 背景
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);
            
            // タイトル（背景付き）
            drawText(ctx, 'アナログ信号とデジタル信号の比較', width/2, 40, {
                font: 'bold 24px',
                align: 'center',
                baseline: 'middle',
                background: '#1a1a1a',
                padding: 10
            });
            
            // セクション分割
            const sections = [
                { title: 'アナログ信号', y: 100, color: '#ff9500' },
                { title: 'デジタル信号', y: 300, color: '#00ff88' }
            ];
            
            sections.forEach(section => {
                // セクションタイトル（重ならないように配置）
                const titleMetrics = drawText(ctx, section.title, 50, section.y, {
                    font: 'bold 18px',
                    color: section.color,
                    baseline: 'bottom'
                });
                
                // 波形エリア（タイトルの下に配置）
                const waveY = section.y + 20;
                const waveHeight = 120;
                
                // 波形背景
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(50, waveY, width - 100, waveHeight);
                
                // グリッド
                ctx.strokeStyle = '#2a2a2a';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const x = 50 + (width - 100) * i / 10;
                    ctx.beginPath();
                    ctx.moveTo(x, waveY);
                    ctx.lineTo(x, waveY + waveHeight);
                    ctx.stroke();
                }
                
                // 波形描画
                ctx.strokeStyle = section.color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                if (section.title === 'アナログ信号') {
                    // サイン波
                    for (let x = 50; x < width - 50; x += 2) {
                        const t = (x - 50) / (width - 100);
                        const y = waveY + waveHeight/2 + Math.sin(t * Math.PI * 4) * waveHeight * 0.3;
                        if (x === 50) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                } else {
                    // デジタル波形
                    const bits = [1, 0, 0, 1, 1, 0, 1, 0];
                    const bitWidth = (width - 100) / bits.length;
                    
                    bits.forEach((bit, i) => {
                        const x1 = 50 + i * bitWidth;
                        const x2 = x1 + bitWidth;
                        const y = bit ? waveY + 20 : waveY + waveHeight - 20;
                        
                        if (i === 0) {
                            ctx.moveTo(x1, y);
                        } else {
                            const prevY = bits[i-1] ? waveY + 20 : waveY + waveHeight - 20;
                            if (y !== prevY) {
                                ctx.lineTo(x1, prevY);
                                ctx.lineTo(x1, y);
                            }
                        }
                        ctx.lineTo(x2, y);
                        
                        // ビット値（重ならないように中央に配置）
                        drawText(ctx, bit.toString(), x1 + bitWidth/2, waveY - 10, {
                            font: '14px',
                            fontFamily: 'monospace',
                            align: 'center',
                            color: section.color
                        });
                    });
                }
                ctx.stroke();
                
                // 説明テキスト（波形の外側に配置）
                const description = section.title === 'アナログ信号' ? 
                    '連続的に変化する信号' : '0と1の2値のみ';
                drawText(ctx, description, width - 50, waveY + waveHeight/2, {
                    font: '14px',
                    align: 'right',
                    baseline: 'middle',
                    color: '#aaaaaa'
                });
            });
        }

        // デモ3: 高DPI対応版
        function drawHdpiDemo() {
            const canvas = document.getElementById('hdpiDemo');
            const ctx = setupCanvas(canvas);
            const width = canvas.getBoundingClientRect().width;
            const height = canvas.getBoundingClientRect().height;
            
            // 背景
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);
            
            // デバイス情報
            const dpr = window.devicePixelRatio || 1;
            drawText(ctx, `デバイスピクセル比: ${dpr}`, width/2, 30, {
                font: '16px',
                align: 'center',
                color: '#666666'
            });
            
            // 細かいグリッドパターン（高DPIで違いが分かる）
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 0.5;
            for (let i = 0; i < width; i += 10) {
                ctx.beginPath();
                ctx.moveTo(i, 50);
                ctx.lineTo(i, height - 50);
                ctx.stroke();
            }
            
            // 精密な波形
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let x = 50; x < width - 50; x += 0.5) {
                const t = (x - 50) / (width - 100);
                const y = height/2 + Math.sin(t * Math.PI * 16) * 50 * Math.exp(-t * 3);
                if (x === 50) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // 小さいテキスト（高DPIで読みやすい）
            for (let i = 0; i < 10; i++) {
                drawText(ctx, `${i * 100}ms`, 50 + i * (width - 100) / 10, height - 30, {
                    font: '10px',
                    align: 'center',
                    color: '#666666'
                });
            }
        }

        // デモ4: 実用的な比較図
        function drawPracticalDemo() {
            const canvas = document.getElementById('practicalDemo');
            const ctx = setupCanvas(canvas);
            const width = canvas.getBoundingClientRect().width;
            const height = canvas.getBoundingClientRect().height;
            
            // 背景
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#0a0a0a');
            gradient.addColorStop(1, '#1a1a1a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            // メインタイトル
            drawText(ctx, 'アナログ信号からデジタル信号への変換', width/2, 50, {
                font: 'bold 28px',
                align: 'center',
                baseline: 'middle',
                color: '#ffffff'
            });
            
            // 3段構成
            const stages = [
                { title: '1. アナログ信号（音声）', y: 120, height: 100 },
                { title: '2. サンプリングと量子化', y: 270, height: 100 },
                { title: '3. デジタル信号（0と1）', y: 420, height: 100 }
            ];
            
            stages.forEach((stage, index) => {
                // ステージタイトル
                drawText(ctx, stage.title, 80, stage.y - 20, {
                    font: 'bold 18px',
                    color: '#00ff88'
                });
                
                // ステージ背景
                ctx.fillStyle = 'rgba(42, 42, 42, 0.5)';
                ctx.fillRect(80, stage.y, width - 160, stage.height);
                
                // 各ステージの内容
                ctx.strokeStyle = '#ff9500';
                ctx.lineWidth = 2;
                
                if (index === 0) {
                    // アナログ波形
                    ctx.beginPath();
                    for (let x = 100; x < width - 100; x++) {
                        const t = (x - 100) / (width - 200);
                        const y = stage.y + stage.height/2 + 
                                 Math.sin(t * Math.PI * 8) * 30 * 
                                 (1 + 0.3 * Math.sin(t * Math.PI * 2));
                        if (x === 100) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    
                } else if (index === 1) {
                    // サンプリング点
                    const samples = 20;
                    for (let i = 0; i < samples; i++) {
                        const x = 100 + (width - 200) * i / (samples - 1);
                        const t = i / (samples - 1);
                        const value = Math.sin(t * Math.PI * 8) * 
                                     (1 + 0.3 * Math.sin(t * Math.PI * 2));
                        const y = stage.y + stage.height/2 - value * 30;
                        
                        // サンプル点
                        ctx.fillStyle = '#4ecdc4';
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // 量子化レベル
                        const quantized = Math.round((value + 1) * 4) / 4 - 1;
                        const qy = stage.y + stage.height/2 - quantized * 30;
                        
                        ctx.strokeStyle = '#4ecdc4';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([2, 2]);
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x, qy);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // 量子化値
                        ctx.fillStyle = '#00ff88';
                        ctx.fillRect(x - 2, qy - 2, 4, 4);
                    }
                    
                } else if (index === 2) {
                    // デジタル信号
                    ctx.strokeStyle = '#00ff88';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    
                    const bits = [1,0,1,1,0,1,0,0,1,1,0,1,0,1];
                    const bitWidth = (width - 200) / bits.length;
                    
                    bits.forEach((bit, i) => {
                        const x1 = 100 + i * bitWidth;
                        const x2 = x1 + bitWidth;
                        const y = bit ? stage.y + 20 : stage.y + stage.height - 20;
                        
                        if (i === 0) {
                            ctx.moveTo(x1, y);
                        } else {
                            const prevY = bits[i-1] ? stage.y + 20 : stage.y + stage.height - 20;
                            if (y !== prevY) {
                                ctx.lineTo(x1, prevY);
                                ctx.lineTo(x1, y);
                            }
                        }
                        ctx.lineTo(x2, y);
                    });
                    ctx.stroke();
                    
                    // ビット値表示
                    ctx.font = '12px monospace';
                    ctx.fillStyle = '#00ff88';
                    ctx.textAlign = 'center';
                    bits.forEach((bit, i) => {
                        const x = 100 + (i + 0.5) * bitWidth;
                        ctx.fillText(bit.toString(), x, stage.y - 5);
                    });
                }
                
                // 矢印（次のステージへ）
                if (index < stages.length - 1) {
                    ctx.strokeStyle = '#666666';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(width/2 - 20, stage.y + stage.height + 15);
                    ctx.lineTo(width/2, stage.y + stage.height + 25);
                    ctx.lineTo(width/2 + 20, stage.y + stage.height + 15);
                    ctx.stroke();
                }
            });
            
            // 説明
            drawText(ctx, '音声などの連続的な信号を、コンピュータで扱える0と1のデータに変換', 
                    width/2, height - 30, {
                font: '14px',
                align: 'center',
                color: '#aaaaaa'
            });
        }

        // すべてのデモを描画
        drawTextDemo();
        drawLayoutDemo();
        drawHdpiDemo();
        drawPracticalDemo();
    </script>
</body>
</html>